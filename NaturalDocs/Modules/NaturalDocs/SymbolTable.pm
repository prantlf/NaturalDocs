###############################################################################
#
#   Package: NaturalDocs::SymbolTable
#
###############################################################################
#
#   A package that handles all the gory details of managing symbols.  It handles where they are defined, which files
#   reference them, if any are undefined or duplicated, and loading and saving them to a file.
#
#   Usage and Dependencies:
#
#       - <NaturalDocs::Settings>, <NaturalDocs::Languages>, and <NaturalDocs::Project> must be initialized before use.
#
#       - <LoadAndPurge()> must be called to initialize the package.  No other functions can be called beforehand.  Afterwards
#         the <Modification Functions> like <AddSymbol()> are available, but the symbol table still isn't fully resolved to the
#         changes in the source tree so the <Information Functions> are still out.
#
#       - <NaturalDocs::Parser->ParseForInformation()> must be called on all files that have changed to fully resolve the symbol
#         table.  Afterwards <PurgeResolvingInfo()> can be called and the <Information Functions> are available.
#
#       - <Save()> must be called to commit any changes to the symbol table back to disk.
#
###############################################################################

# This file is part of Natural Docs, which is Copyright © 2003 Greg Valure
# Natural Docs is licensed under the GPL


use NaturalDocs::SymbolTable::Symbol;
use NaturalDocs::SymbolTable::SymbolDefinition;
use NaturalDocs::SymbolTable::Reference;
use NaturalDocs::SymbolTable::File;
use NaturalDocs::SymbolTable::ReferenceTarget;
use NaturalDocs::SymbolTable::IndexElement;

use strict;
use integer;

package NaturalDocs::SymbolTable;


###############################################################################
# Group: Variables

#
#   hash: symbols
#
#   A hash of all symbols, both those that are defined and those which are simply potential interpretations of references.  The
#   keys are the symbol strings, generated by by <MakeSymbolString()>, and the values are
#   <NaturalDocs::SymbolTable::Symbol> objects.  Note that because references can have many interpretations, there will
#   probably be more symbols here that aren't defined than that are.
#
my %symbols;

#
#   hash: references
#
#   A hash of all references in the project.  The keys are the reference strings, generated by by <MakeReferenceString()>,
#   and the values are <NaturalDocs::SymbolTable::Reference> objects.
#
my %references;

#
#   hash: files
#
#   A hash of all the files that define symbols and references in the project.  The keys are the file names, and the values are
#   <NaturalDocs::SymbolTable::File> objects.
#
my %files;

#
#   object: watchedFile
#
#   A <NaturalDocs::SymbolTable::File> object of the file being watched for changes.  This is compared to the version in <files>
#   to see if anything was changed since the last parse.
#
my $watchedFile;

#
#   string: watchedFileName
#
#   The file name of the watched file, if any.  If there is no watched file, this will be undef.
#
my $watchedFileName;

#
#   hash: watchedFileSymbolDefinitions
#
#   A hashref of the symbol definition information for all the symbols in the watched file.  The keys are the symbol strings, and the
#   values are <NaturalDocs::SymbolTable::SymbolDefinition> objects.
#
my %watchedFileSymbolDefinitions;


#
#   hash: indexes
#
#   A hash of generated symbol indexes.  The keys are <Topic Types> or *, and the values are sorted arrayrefs of
#   <NaturalDocs::SymbolTable::IndexElements>.  A key of * means the index is not limited to a topic type.
#
my %indexes;


#
#   hash: indexChanges
#
#   An existence hash of all the indexes that have changed.  The keys are the <Topic Types>.  Unlike <indexes>, there is no *
#   entry.  Simply check if there are any defined keys instead.
#
my %indexChanges;


###############################################################################
# Group: Files

#
#   File: NaturalDocs.sym
#
#   The storage file for the symbol table.
#
#   Format:
#
#       The beginning of the file is the application version that generated it.  Handle it using the text file functions in
#       <NaturalDocs::Version>.
#
#       > [app version]
#
#       The first stage of the file is for symbol definitions, analogous to <symbols>.  For this stage, each entry continues until it
#       reaches a blank line.  The first line is the symbol string, and each subsequent line is a tab separated list of the definition,
#       type, prototype, and summary.  The first file on this list will be the one that has the global definition.  Undefined symbols are
#       not included here.
#
#       > [symbol string]
#       > [global definition file] tab [symbol type] tab [prototype] tab [summary]
#       > [definition file] tab [symbol type] tab [prototype] tab [summary]
#       > blank line
#
#       The two stages are separated by a blank line.  That works out to meaning a symbol definition followed by two blank lines.
#
#       > blank line
#
#       The second stage is for references, which is analogous to <references>.  For this stage, each is a pair of lines.  The first line
#       is the reference string, and the second is a tab separated list of the files that define it.  The interpretations will be
#       regenerated.
#
#       > [reference string]
#       > [definition file] tab [definition file] tab [definition file] ...
#
#   Revisions:
#
#       Prior to 1.1, there was no summary saved in the symbol definition lines.
#
#       Prior to 0.95, the version line was 1.  Test for "1" instead of "1.0" to distinguish.  Other than that, the file format has not
#       changed since its public release.
#


###############################################################################
# Group: File Functions


#
#   Function: LoadAndPurge
#
#   Loads the symbol table from disk, and purges everything associated with files that no longer have Natural Docs content.
#
sub LoadAndPurge
    {
    my ($self) = @_;

    my $line;
    my $fileIsOkay;

    if (!NaturalDocs::Settings->RebuildData() && open(SYMBOLTABLEFILEHANDLE, '<' . NaturalDocs::Project->SymbolTableFile()))
        {
        # Check if the version is okay.

        my $version = NaturalDocs::Version->FromTextFile(\*SYMBOLTABLEFILEHANDLE);

        # There were bugs in prototype detection until 1.13.  Need to regenerate the symbol table.

        if ($version >= NaturalDocs::Version->FromString('1.13') && $version <= NaturalDocs::Settings->AppVersion())
            {  $fileIsOkay = 1;  }
        else
            {  close(SYMBOLTABLEFILEHANDLE);  };
        };


    # If something's wrong with the file, we need to reparse everything.
    if (!$fileIsOkay)
        {
        NaturalDocs::Project->ReparseEverything();
        return;
        };


    # Symbol definitions

    while ($line = <SYMBOLTABLEFILEHANDLE>)
        {
        chomp($line);

        # Putting this in the while condition causes problems.
        if (!length $line)
            {  last;  };

        # [symbol string]

        my $symbolString = $line;
        my $symbolObject = NaturalDocs::SymbolTable::Symbol->New();

        $line = <SYMBOLTABLEFILEHANDLE>;
        chomp($line);

        while (length $line)
            {
            # [definition] tab [type] tab [prototype] tab [summary]

            my ($file, $type, $prototype, $summary) = split(/\t/, $line);

            if (!$prototype)
                {  $prototype = undef;  };
            if (!$summary)
                {  $summary = undef;  };

            $symbolObject->AddDefinition($file, $type, $prototype, $summary);

            if (!exists $files{$file})
                {  $files{$file} = NaturalDocs::SymbolTable::File->New();  };

            $files{$file}->AddSymbol($symbolString);

            $line = <SYMBOLTABLEFILEHANDLE>;
            chomp($line);
            };

        $symbols{$symbolString} = $symbolObject;
        };


    # References

    while ($line = <SYMBOLTABLEFILEHANDLE>)
        {
        chomp($line);

        # [reference string]

        my $referenceString = $line;
        my $referenceObject = NaturalDocs::SymbolTable::Reference->New();

        $line = <SYMBOLTABLEFILEHANDLE>;
        chomp($line);

        # [definition] tab [definition] tab [definition] ...

        my @definitions = split(/\t/, $line);

        foreach my $definition (@definitions)
            {
            $referenceObject->AddDefinition($definition);

            if (!exists $files{$definition})
                {  $files{$definition} = NaturalDocs::SymbolTable::File->New();  };

            $files{$definition}->AddReference($referenceString);
            };

        $references{$referenceString} = $referenceObject;


        # Get the possible interpretations and add them to the tables.

        my ($scope, $reference) = $self->DecodeReferenceString($referenceString);

        $self->GenerateInterpretations($scope, $reference);
        $self->InterpretReference($referenceString);
        };


    close(SYMBOLTABLEFILEHANDLE);

    $self->Purge();
    };

#
#   Function: Save
#
#   Saves the symbol table to disk.  It is written to <NaturalDocs.sym>.
#
sub Save
    {
    my ($self) = @_;

    open(SYMBOLTABLEFILEHANDLE, '>' . NaturalDocs::Project->SymbolTableFile())
        or die "Couldn't save project file " . NaturalDocs::Project->SymbolTableFile() . "\n";


    NaturalDocs::Version->ToTextFile(\*SYMBOLTABLEFILEHANDLE, NaturalDocs::Settings->AppVersion());


    # Symbols

    while (my ($symbol, $symbolObject) = each %symbols)
        {
        # Only existing symbols.
        if ($symbolObject->IsDefined())
            {
            print SYMBOLTABLEFILEHANDLE $symbol . "\n"
                                  . $symbolObject->GlobalDefinition() . "\t"
                                  . $symbolObject->GlobalType() . "\t"
                                  . $symbolObject->GlobalPrototype() . "\t"
                                  . $symbolObject->GlobalSummary() . "\n";

            my @definitions = $symbolObject->Definitions();

            foreach my $definition (@definitions)
                {
                if ($definition ne $symbolObject->GlobalDefinition())
                    {
                    print SYMBOLTABLEFILEHANDLE $definition . "\t"
                                          . $symbolObject->TypeDefinedIn($definition) . "\t"
                                          . $symbolObject->PrototypeDefinedIn($definition) . "\t"
                                          . $symbolObject->SummaryDefinedIn($definition) ."\n";
                    };
                };

            print SYMBOLTABLEFILEHANDLE "\n";
            };
        };


    # Separator

    print SYMBOLTABLEFILEHANDLE "\n";


    # References

    while (my ($reference, $referenceObject) = each %references)
        {
        print SYMBOLTABLEFILEHANDLE $reference . "\n";

        my @definitions = $referenceObject->Definitions();
        print SYMBOLTABLEFILEHANDLE join("\t", @definitions) . "\n";
        };


    close(SYMBOLTABLEFILEHANDLE);
    };


###############################################################################
# Group: Modification Functions

#
#   Function: AddSymbol
#
#   Adds a symbol definition to the table, if it doesn't already exist.  If the definition changes or otherwise requires the files that
#   reference it to be updated, the function will call <NaturalDocs::Project->RebuildFile()> to make sure that they are.
#
#   Parameters:
#
#       class     - The symbol's class.  If none, set to undef.
#       symbol  - The symbol's name.
#       file        - The file name where it's defined.
#       type      - The symbol's type.
#       prototype - The symbol's prototype, if applicable.
#       summary - The symbol's summary, if applicable.
#
sub AddSymbol #(class, symbol, file, type, prototype, summary)
    {
    my ($self, $class, $symbol, $file, $type, $prototype, $summary) = @_;

    my $symbolString = $self->MakeSymbolString($class, $symbol);


    # If the symbol doesn't exist...
    if (!exists $symbols{$symbolString})
        {
        # Create the symbol.  There are no references that could be interpreted as this or else it would have existed already.

        my $newSymbol = NaturalDocs::SymbolTable::Symbol->New();
        $newSymbol->AddDefinition($file, $type, $prototype, $summary);

        $symbols{$symbolString} = $newSymbol;

        $indexChanges{$type} = 1;
        }


    # If the symbol already exists...
    else
        {
        my $symbolObject = $symbols{$symbolString};

        # If the symbol isn't defined, i.e. it was a potential interpretation only...
        if (!$symbolObject->IsDefined())
            {
            $symbolObject->AddDefinition($file, $type, $prototype, $summary);

            # See if this symbol provides a better interpretation of any references, and rebuild the reference files if it does.
            # We can assume this symbol has interpretations, because the object won't exist without either that or definitions.

            my %referencesAndScores = $symbolObject->ReferencesAndScores();

            while (my ($reference, $referenceScore) = each %referencesAndScores)
                {
                my $referenceObject = $references{$reference};

                if (!$referenceObject->HasCurrentInterpretation() ||
                    $referenceScore > $referenceObject->CurrentScore())
                    {
                    $referenceObject->SetCurrentInterpretation($symbolString);

                    my @referenceDefinitions = $referenceObject->Definitions();
                    foreach my $referenceDefinition (@referenceDefinitions)
                        {
                        NaturalDocs::Project->RebuildFile($referenceDefinition);
                        };
                    };
                };

            $indexChanges{$type} = 1;
            }

        # If the symbol is defined but not in this file...
        elsif (!$symbolObject->IsDefinedIn($file))
            {
            $symbolObject->AddDefinition($file, $type, $prototype, $summary);

            $indexChanges{$type} = 1;

            # There's only one potential issue here, which is if this definition is new and the file references this symbol.  The file would
            # need to be rebuilt because its own definition takes precedence over the global one.  However, the only way for a file
            # to be adding symbols in the first place is if it is being parsed and has content, in which case it's going to be rebuilt
            # anyway, so we don't have to detect this condition.

            # We don't have to check other files, by the way, because if the symbol is defined it already has a global definiton,
            # and everything else is either using that or its own definition, and thus wouldn't be affected by this.
            };

        # If the symbol was already defined in this file, ignore it.

        };


    # Add it to the file index.

    if (!exists $files{$file})
        {  $files{$file} = NaturalDocs::SymbolTable::File->New();  };

    $files{$file}->AddSymbol($symbolString);


    # Add it to the watched file, if necessary.

    if (defined $watchedFileName)
        {
        $watchedFile->AddSymbol($symbolString);

        if (!exists $watchedFileSymbolDefinitions{$symbolString})
            {
            $watchedFileSymbolDefinitions{$symbolString} =
                 NaturalDocs::SymbolTable::SymbolDefinition->New($type, $prototype, $summary);
            };
        };
    };


#
#   Function: AddReference
#
#   Adds a reference to the table, if it doesn't already exist.
#
#   Parameters:
#
#       scope       - The class scope it appears in.  Set to undef if none.
#       reference - The reference text.
#       file           - The file name where the reference is.
#
sub AddReference #(scope, reference, file)
    {
    my ($self, $scope, $reference, $file) = @_;

    my $referenceString = $self->MakeReferenceString($scope, $reference);


    # If the reference doesn't exist...
    if (!exists $references{$referenceString})
        {
        my $referenceObject = NaturalDocs::SymbolTable::Reference->New();
        $referenceObject->AddDefinition($file);

        $references{$referenceString} = $referenceObject;

        $self->GenerateInterpretations($scope, $reference);
        $self->InterpretReference($referenceString);
        }

    # If the reference exists...
    else
        {
        $references{$referenceString}->AddDefinition($file);
        };


    # Add it to the file index.

    if (!exists $files{$file})
        {  $files{$file} = NaturalDocs::SymbolTable::File->New();  };

    $files{$file}->AddReference($referenceString);


    # Add it to the watched file, if necessary.

    if (defined $watchedFileName)
        {  $watchedFile->AddReference($referenceString);  };
    };


#
#   Function: WatchFileForChanges
#
#   Tracks a file to see if any symbols or references were changed or deleted in ways that would require other files to be rebuilt.
#   Assumes that after this function call, the entire file will be parsed again, and thus every symbol and reference will go through
#   <AddSymbol()> and <AddReference()>.  Afterwards, call <AnalyzeChanges()> to handle any differences.
#
#   Parameters:
#
#       file - The file to watch.
#
sub WatchFileForChanges #(file)
    {
    my ($self, $file) = @_;

    $watchedFile = NaturalDocs::SymbolTable::File->New();
    $watchedFileName = $file;
    %watchedFileSymbolDefinitions = ( );
    };


#
#   Function: AnalyzeChanges
#
#   Handles any changes found when reparsing a file using <WatchFileForChanges()>.
#
sub AnalyzeChanges
    {
    my ($self) = @_;

    if (exists $files{$watchedFileName})
        {

        # Go through the references and remove any that were deleted.  Ones that were added will have already been added to
        # the table in AddReference().

        my @references = $files{$watchedFileName}->References();
        foreach my $reference (@references)
            {
            if (!$watchedFile->DefinesReference($reference))
                {  $self->DeleteReference($reference, $watchedFileName);  };
            };


        # Go through the symbols.

        my @symbols = $files{$watchedFileName}->Symbols();
        foreach my $symbol (@symbols)
            {
            # Delete symbols that don't exist.

            if (!$watchedFile->DefinesSymbol($symbol))
                {
                $self->DeleteSymbol($symbol, $watchedFileName);
                }

            else
                {
                my $symbolObject = $symbols{$symbol};
                my $newSymbolDef = $watchedFileSymbolDefinitions{$symbol};

                # Update symbols that changed.

                if ( $symbolObject->TypeDefinedIn($watchedFileName) != $newSymbolDef->Type() ||
                     $symbolObject->PrototypeDefinedIn($watchedFileName) ne $newSymbolDef->Prototype() ||
                     $symbolObject->SummaryDefinedIn($watchedFileName) ne $newSymbolDef->Summary() )
                    {
                    $indexChanges{$symbolObject->TypeDefinedIn($watchedFileName)} = 1;
                    $indexChanges{$newSymbolDef->Type()} = 1;

                    $symbolObject->ChangeDefinition($watchedFileName, $newSymbolDef->Type(), $newSymbolDef->Prototype(),
                                                                       $newSymbolDef->Summary());

                    # If the symbol definition was the global one, we need to update all files that reference it.  If it wasn't, the only file
                    # that could references it is itself, and the only way the symbol definition could change in the first place was if it was
                    # itself changed.
                    if ($symbolObject->GlobalDefinition() eq $watchedFileName)
                        {
                        # Rebuild the files that have references to this symbol
                        my @references = $symbolObject->References();
                        foreach my $reference (@references)
                            {
                            my $referenceObject = $references{$reference};
                            if ($referenceObject->CurrentInterpretation() eq $symbol)
                                {
                                my @definitions = $referenceObject->Definitions();
                                foreach my $referenceFile (@definitions)
                                    {  NaturalDocs::Project->RebuildFile($referenceFile);  };
                                }; # If reference interprets as symbol
                            }; # While references
                        }; # If global definition is watched file
                    }; # If the symbol definition changed
                }; # If the symbol still exists
            }; # foreach symbol in watched file

        };


    $watchedFile = undef;
    $watchedFileName = undef;
    %watchedFileSymbolDefinitions = ( );
    };


#
#   Function: PurgeResolvingInfo
#
#   Purges unnecessary information from the symbol table after it is fully resolved.  This will reduce the memory footprint for the
#   build stage.  After calling this function, you can only call the <Information Functions> and <Save()>.
#
sub PurgeResolvingInfo
    {
    my ($self) = @_;

    # Go through the symbols.  We don't need to keep around potential symbols anymore, nor do we need what references can
    # be interpreted as the defined ones.

    while (my ($symbolString, $symbolObject) = each %symbols)
        {
        if ($symbolObject->IsDefined())
            {  $symbolObject->DeleteAllReferences();  }
        else
            {  delete $symbols{$symbolString};  };
        };


    # Go through the references.  We don't need any of the interpretations except for the current.

    foreach my $referenceObject (values %references)
        {  $referenceObject->DeleteAllInterpretationsButCurrent();  };


    # We don't need the information by file at all.

    %files = ( );
    };


#
#   Function: PurgeIndexes
#
#   Clears all generated indexes.
#
sub PurgeIndexes
    {
    my ($self) = @_;
    %indexes = ( );
    };


###############################################################################
# Group: Information Functions
# These functions should not be called until the symbol table is fully resolved.


#
#   Function: Defines
#
#   Returns the symbol the passed class and name define.  This is *not* exactly the same as what was passed.  Certain
#   elements may be taken out to make pattern matching more tolerant, so you *must* use this function when defining
#   symbols in output files to match the tolerance of this package.
#
#   For example, say there's a symbol definition A-space-space-B.  SymbolTable condenses whitespace, so the symbol
#   can also be referenced by A-space-B, A-tab-B, A-space-space-space-B, etc.  In effect, A-space-space-B really defines
#   the symbol A-space-B.  If you encoded the anchor as A-space-space-B in the output file, when <References()> returns
#   A-space-B, they won't match.  If you run it through this function first, they always will.
#
#   Note that this is only required when encoding symbol definitions in output files.  Every other SymbolTable function handles
#   this automatically, so you don't need to run symbols through this to call <AddSymbol()> etc.
#
#   Parameters:
#
#       class      - The symbol's class.  Remember that if you got this value direct from <NDMarkup>, you must run it
#                      through <NaturalDocs::NDMarkup->RestoreAmpChars()> first.  Use undef if the symbol is global.
#       symbol  - The symbol's name.  You also need to run this through <NaturalDocs::NDMarkup->RestoreAmpChars()> if it was
#                      gotten from <NDMarkup>.
#
#   Returns:
#
#       The defined symbol as the array ( class, symbol ).  If class was undef in the parameters, it will be undef here too.
#
sub Defines #(class, symbol)
    {
    my ($self, @symbol) = @_;

    if (defined $symbol[0])
        {  $symbol[0] = $self->PrepareString($symbol[0]);  };

    $symbol[1] = $self->PrepareString($symbol[1]);

    return @symbol;
    };


#
#   Function: References
#
#   Returns what the passed symbol and scope reference, if anything.  Note that this only works if the reference had been
#   previously added to the table via <AddReference()>.
#
#   Parameters:
#
#       scope        - The scope the symbol appears in.  Note that if you got this value direct from <NDMarkup>, you must run
#                          it through <NaturalDocs::NDMarkup->RestoreAmpChars()> first.  Use undef if the reference appears as global.
#       reference   - The reference text.  You need to run this through <NaturalDocs::NDMarkup->RestoreAmpChars()> too if
#                          necessary.
#       file            - The source file the reference appears in.  This is important because if a symbol is defined in multiple places,
#                          the definition in the same file as the reference gets priority.
#
#   Returns:
#
#       A <NaturalDocs::SymbolTable::ReferenceTarget> object, or undef if the reference doesn't resolve to anything.
#
sub References #(scope, reference, file)
    {
    my ($self, $scope, $reference, $file) = @_;

    my $referenceString = $self->MakeReferenceString($scope, $reference);

    if (exists $references{$referenceString} && $references{$referenceString}->HasCurrentInterpretation())
        {
        my $targetString = $references{$referenceString}->CurrentInterpretation();
        my $targetObject = $symbols{$targetString};

        my ($class, $symbol) = $self->DecodeSymbolString($targetString);

        my $targetFile;
        my $type;
        my $prototype;
        my $summary;

        if ($targetObject->IsDefinedIn($file))
            {
            $targetFile = $file;
            $type = $targetObject->TypeDefinedIn($file);
            $prototype = $targetObject->PrototypeDefinedIn($file);
            $summary = $targetObject->SummaryDefinedIn($file);
            }
        else
            {
            $targetFile = $targetObject->GlobalDefinition();
            $type = $targetObject->GlobalType();
            $prototype = $targetObject->GlobalPrototype();
            $summary = $targetObject->GlobalSummary();
            };

        return NaturalDocs::SymbolTable::ReferenceTarget->New($class, $symbol, $targetFile, $type, $prototype, $summary);
        }

    else
        {  return undef;  };
    };


#
#   Function: Index
#
#   Returns a symbol index.
#
#   Indexes are generated on demand, but they are stored so subsequent calls for the same index will be fast.  Call
#   <PurgeIndexes()> to clear the generated indexes.
#
#   Parameters:
#
#       type  - The type of symbol to limit the index to, or undef for none.  Should be one of the <Topic Types>.
#
#   Returns:
#
#       A sorted arrayref of <NaturalDocs::SymbolTable::IndexElement> objects.
#
sub Index #(type)
    {
    my ($self, $type) = @_;

    my $key = ($type || '*');

    if (!exists $indexes{$key})
        {
        $indexes{$key} = $self->MakeIndex($type);
        };

    return $indexes{$key};
    };


#
#   Function: HasIndexes
#
#   Determines which indexes out of a list actually have content.
#
#   Parameters:
#
#       types  - An existence hashref of the symbols to check for indexes.  The keys are the <Topic Types> or * for general.
#
#   Returns:
#
#       An existence hashref of all the specified indexes that have content.  Will return an empty hashref if none.
#
sub HasIndexes #(types)
    {
    my ($self, $types) = @_;

    my %eliminationHash = %$types;

    finddefs:
    foreach my $symbolObject (values %symbols)
        {
        foreach my $definition ($symbolObject->Definitions())
            {
            delete $eliminationHash{ $symbolObject->TypeDefinedIn($definition) };
            delete $eliminationHash{ '*' };

            if (!scalar keys %eliminationHash)
                {  last finddefs;  };
            };
        };

    my $result = { %$types };

    foreach my $type (keys %eliminationHash)
        {  delete $result->{$type};  };

    return $result;
    };

#
#   Function: IndexChanged
#
#   Returns whether the specified index has changed.
#
#   Parameters:
#
#       type  - The type of symbol to limit the index to, or undef if none.  Should be one of the <Topic Types>.
#
sub IndexChanged #(type)
    {
    my ($self, $type) = @_;

    if ($type)
        {  return (exists $indexChanges{$type});  }
    else
        {  return (scalar keys %indexChanges > 0);  };
    };


###############################################################################
# Group: Support Functions

#
#   Function: Purge
#
#   Purges the symbol table of all symbols and references from files that no longer have Natural Docs content.
#
sub Purge
    {
    my ($self) = @_;

    my $filesToPurge = NaturalDocs::Project->FilesToPurge();

    # We do this in two stages.  First we delete all the references, and then we delete all the definitions.  This causes us to go
    # through the list twice, but it makes sure no purged files get added to the build list.  For example, if we deleted all of
    # Purge File A's references and definitions, and Purge File B had a reference to one of those symbols, Purge File B
    # would be added to the build list because one of its references changed.  By removing all the references in all the files
    # before removing the definitions, we avoid this.

    foreach my $file (keys %$filesToPurge)
        {
        if (exists $files{$file})
            {
            my @references = $files{$file}->References();
            foreach my $reference (@references)
                {  $self->DeleteReference($reference, $file);  };
            };
        };

    foreach my $file (keys %$filesToPurge)
        {
        if (exists $files{$file})
            {
            my @symbols = $files{$file}->Symbols();
            foreach my $symbol (@symbols)
                {  $self->DeleteSymbol($symbol, $file);  };

            delete $files{$file};
            };
        };
    };


#
#   Function: MakeSymbolString
#
#   Encodes the symbol information as a string.  The format of the string should be treated as opaque and the string should not
#   be used for anything other than direct comparison, file I/O, and hash keys.  The only characteristic of the encoding you can
#   depend on is that it will not contain line breaks, which should make using them in text files easier.
#
#   Parameters:
#
#       class - The class the symbol is part of.  Use undef if it is global.
#       symbol - The name of the symbol itself.
#
#   Returns:
#
#       The encoded symbol string.
#
sub MakeSymbolString #(class, symbol)
    {
    my ($self, $class, $symbol) = @_;

    # If there's no class, the encoded symbol is just symbol.  Otherwise it's class-tab-symbol.  Tab was chosen because
    # PrepareString removes them, so there won't be any conflicts.

    $symbol = $self->PrepareString($symbol);

    if ($class)
        {  $symbol = $self->PrepareString($class) . "\t" . $symbol;  };

    return $symbol;
    };

#
#   Function: MakeReferenceString
#
#   Encodes the reference information as a string.  The format of the string should be treated as opaque and the string should
#   not be used for anything other than direct comparison, file I/O, and hash keys.  The only characteristic of the encoding you
#   can depend on is that it will not contain line breaks, which should make using them in text files easier.
#
#   Parameters:
#
#       scope - The scope the reference appears in.  Use undef if it is global.  Note that just because the reference appears in a
#                 scope does not necessarily mean the reference is to something in that scope.  Also, it doesn't mean the
#                 reference doesn't already have a scope specified within it.
#       reference - The text of the reference itself.
#
#   Returns:
#
#       The encoded reference string.
#
sub MakeReferenceString #(scope, reference)
    {
    my ($self, @params) = @_;

    # Just use the same format as MakeSymbolString().
    return $self->MakeSymbolString(@params);
    };


#
#   Function: DecodeSymbolString
#
#   Returns the class and symbol encoded in a symbol string.
#
#   Parameters:
#
#       symbolString - The symbol string to decode.
#
#   Returns:
#
#       The array ( class, symbol ).  If the symbol is global, class will be undef.
#
sub DecodeSymbolString #(symbolString)
    {
    my ($self, $symbolString) = @_;

    my @array = split(/\t/, $symbolString);

    if (scalar @array == 1)
        {  return ( undef, $array[0] );  }
    else
        {  return @array;  };
    };


#
#   Function: DecodeReferenceString
#
#   Returns the scope and reference encoded in a reference string.
#
#   Parameters:
#
#       referenceString - The reference string to decode.
#
#   Returns:
#
#       The array ( scope, reference ).  If the reference is global, scope will be undef.
#
sub DecodeReferenceString #(referenceString)
    {
    my ($self, $referenceString) = @_;

    my @array = split(/\t/, $referenceString);

    if (scalar @array == 1)
        {  return ( undef, $array[0] );  }
    else
        {  return @array;  };
    };


#
#   Function: PrepareString
#
#   Takes a symbol, reference, class, or scope and removes any minor features that could interfere with matching.
#
#   Parameters:
#
#       string - The symbol, reference, class, or scope to be cleaned.
#
#   Returns:
#
#       The cleaned string ready for output.
#
sub PrepareString #(string)
    {
    my ($self, $string) = @_;

    # Convert tabs to spaces.
    $string =~ s/\t/ /g;

    # Remove spaces unless they're separating two alphanumeric/underscore characters.
    $string =~ s/^ +//;
    $string =~ s/ +$//;
    $string =~ s/(\W) +/$1/g;
    $string =~ s/ +(\W)/$1/g;

    # Remove trailing empty parenthesis, so both Function and Function() styles will work.
    $string =~ s/\(\)$//;

    return $string;
    };


#
#   Function: DeleteSymbol
#
#   Removes a symbol definition from the table.  If any files reference it, the function will call <NaturalDocs::Project->RebuildFile()>
#   for them.
#
#   External code should not attempt to delete symbols using this function.  Instead it should call <WatchFileFoChanges()>,
#   reparse the file, and call <AnalyzeChanges()>.
#
#   Parameters:
#
#       symbolString    - The symbol string made from <MakeSymbolString()>.
#       file                - The file name where it was defined.
#
sub DeleteSymbol #(symbolString, file)
    {
    my ($self, $symbolString, $file) = @_;


    # If the symbol and definition exist...
    if (exists $symbols{$symbolString} && $symbols{$symbolString}->IsDefinedIn($file))
        {
        my $symbolObject = $symbols{$symbolString};
        my $wasGlobal = ($symbolObject->GlobalDefinition() eq $file);

        $indexChanges{$symbolObject->TypeDefinedIn($file)} = 1;

        $symbolObject->DeleteDefinition($file);

        # If this was one definition of many...
        if ($symbolObject->IsDefined())
            {

            # If this was the global definition...
            if ($wasGlobal)
                {
                # Rebuild every file that referenced the global symbol; i.e. every file that doesn't have its own definition.

                my @references = $symbolObject->References();

                foreach my $reference (@references)
                    {
                    my $referenceObject = $references{$reference};

                    if ($referenceObject->CurrentInterpretation() eq $symbolString)
                        {
                        my @referenceFiles = $referenceObject->Definitions();
                        foreach my $referenceFile (@referenceFiles)
                            {
                            # If the symbol isn't defined in the file that has a reference to it...
                            # In other words, if the file with the reference didn't have its own definition, so it used the global definition...
                            if (!$symbolObject->IsDefinedIn($referenceFile))
                                {  NaturalDocs::Project->RebuildFile($referenceFile);  };
                            };
                        };
                    };
                }

            # If this wasn't the global definition...
            else
                {
                # It's a safe bet that we don't need to do anything here.  The only thing that we even need to look for here is if the
                # file referenced its own symbol and thus should be rebuilt.  However, if the file is having a symbol deleted, it either
                # changed or was itself deleted.  If it changed and still has other Natural Docs content, it should already be on the
                # rebuild list.  If it was deleted or no longer has Natural Docs content, we certainly don't want to add it to the rebuild
                # list.
                };
            }

        # If this is the only definition...
        else
            {
            # If this symbol is the interpretation of any references...
            if ($symbolObject->HasReferences())
                {
                # If this was the current interpretation of any references, reinterpret them and rebuild their files.

                my @references = $symbolObject->References();
                foreach my $reference (@references)
                    {
                    my $referenceObject = $references{$reference};
                    if ($referenceObject->CurrentInterpretation() eq $symbolString)
                        {
                        $self->InterpretReference($reference);

                        my @definitions = $referenceObject->Definitions();
                        foreach my $referenceFile (@definitions)
                            {  NaturalDocs::Project->RebuildFile($referenceFile);  };
                        };
                    };
                }

            # If there are no interpretations of the symbol...
            else
                {
                # Delete the symbol entirely.
                delete $symbols{$symbolString};
                };
            };

        # Remove it from the file index.

        $files{$file}->DeleteSymbol($symbolString);

        if (!$files{$file}->HasAnything())
            {  delete $files{$file};  };


        # We don't need to worry about the watched file, since this function will only be called by AnalyzeChanges() and
        # LoadAndPurge().
        };
    };


#
#   Function: DeleteReference
#
#   Deletes a reference from the table.  Be careful with this function, as deleting a reference means there are no more of
#   them in the file at all.  The tables do not keep track of how many times references appear in a file.
#
#   External code should not attempt to delete references using this function.  Instead it should call <WatchFileFoChanges()>,
#   reparse the file, and call <AnalyzeChanges()>.
#
#   Parameters:
#
#       referenceString - The reference string generated by <MakeReferenceString()>.
#       file                    - The file name where the reference is.
#
sub DeleteReference #(referenceString, file)
    {
    my ($self, $referenceString, $file) = @_;


    # If the reference exists...
    if (exists $references{$referenceString})
        {
        my $referenceObject = $references{$referenceString};
        $referenceObject->DeleteDefinition($file);

        # If there are no other definitions...
        if (!$referenceObject->IsDefined())
            {
            my @interpretations = $referenceObject->Interpretations();
            foreach my $interpretation (@interpretations)
                {
                $symbols{$interpretation}->DeleteReference($referenceString);
                };

            delete $references{$referenceString};
            };


        # Remove it from the file index.

        $files{$file}->DeleteReference($referenceString);

        if (!$files{$file}->HasAnything())
            {  delete $files{$file};  };

        # We don't need to worry about the watched file, since this function will only be called by AnalyzeChanges() and
        # LoadAndPurge().
        };
    };


#
#   Function: GenerateInterpretations
#
#   Generates the list of interpretations for the passed reference.  Also creates potential symbols as necessary.
#
#   Parameters:
#
#       scope       - The scope the reference appeared in.  Set to undef if global.
#       reference - The text of the reference.
#
sub GenerateInterpretations #(scope, reference)
    {
    my ($self, $scope, $reference) = @_;
    my $referenceString = $self->MakeReferenceString($scope, $reference);

    my @splitReference = NaturalDocs::Languages->SeparateMember($reference);

    # If we found a member separator, it's either that or a global.  We're not supporting members that have their own member
    # separators.

    if (scalar @splitReference == 2)
        {
        # Lower priority is the symbol interpreted as a global with the separator as part of the name.

        my @singulars = $self->GenerateSingularInterpretations($reference);
        my $score = 1;

        foreach my $singular (@singulars)
            {
            $self->AddInterpretation($referenceString, undef, $singular, $score);
            $score++;
            };

        $self->AddInterpretation($referenceString, undef, $reference, $score);
        $score++;

        # Higher priority is the symbol interpreted as a class and symbol.

        @singulars = $self->GenerateSingularInterpretations($splitReference[1]);

        foreach my $singular (@singulars)
            {
            $self->AddInterpretation($referenceString, $splitReference[0], $singular, $score);
            $score++;
            };

        $self->AddInterpretation($referenceString, $splitReference[0], $splitReference[1], $score);
        }


    # If there wasn't a member separator, we can resolve it as a local or a global.

    else
        {
        my @singulars = $self->GenerateSingularInterpretations($reference);
        my $score = 1;

        # Lower priority is the symbol interpreted as a global.

        foreach my $singular (@singulars)
            {
            $self->AddInterpretation($referenceString, undef, $singular, $score);
            $score++;
            };

        $self->AddInterpretation($referenceString, undef, $reference, $score);
        $score++;

        # Higher priority is the symbol as part of the current scope.

        if (defined $scope)
            {
            foreach my $singular (@singulars)
                {
                $self->AddInterpretation($referenceString, $scope, $singular, $score);
                $score++;
                };

            $self->AddInterpretation($referenceString, $scope, $reference, $score);
            };
        };
    };

#
#   Function: GenerateSingularInterpretations
#
#   Generates singular interpretations of a symbol if it can be interpreted as a plural.  Will strip extensions such as -s, -es, and -'s.
#
#   Parameters:
#
#       symbol - The symbol part of the reference.
#
#   Returns:
#
#       An array of potential singular interpretations, in no particular order.  If the symbol can't be interpreted as a plural, returns
#       an empty array.
#
sub GenerateSingularInterpretations #(symbol)
    {
    my ($self, $symbol) = @_;
    my @results;

    # First cut off any 's or ' at the end, since they can appear after other plural forms.
    if ($symbol =~ s/\'s?$//i)
        {
        push @results, $symbol;
        };

    # See http://www.gsu.edu/~wwwesl/egw/crump.htm for a good list of potential plural forms.  There are a couple more than
    # listed below, but they're fairly rare and this is already seriously over-engineered.  This is split by suffix length to make
    # comparisons more efficient.

    # The fact that this will generate some impossible combinations (leaves => leave, leav, leaf, leafe) doesn't matter.  It's very
    # unlikely that more than one will manage to match a defined symbol.  Even if they do (leave, leaf), it's incredibly unlikely
    # that someone has defined an impossible one (leav, leafe).  So it's not so important that we remove impossible combinations,
    # just that we include all the possible ones.

    my @suffixGroups = ( [ 's', undef,  # boys => boy
                                       'i', 'us',  # alumni => alumnus
                                       'a', 'um', # errata => erratum
                                       'a', 'on' ],  # phenomena => phenomenon

                                    [ 'es', undef,  # foxes => fox
                                      'ae', 'a' ],  # amoebae => amoeba

                                    [ 'ies', 'y',  # pennies => penny
                                      'ves', 'f',  # calves => calf
                                      'ves', 'fe',  # knives => knife
                                      'men', 'man',  # women => woman
                                      'ice', 'ouse',  # mice => mouse
                                      'oes', 'o',  # vetoes => veto
                                      'ces', 'x',  # matrices => matrix
                                      'xen', 'x' ],  # oxen => ox

                                    [ 'ices', 'ex',  # indices => index
                                      'feet', 'foot',  # feet => foot
                                      'eese', 'oose',  # geese => goose
                                      'eeth', 'ooth',  # teeth => tooth
                                      'dren', 'd' ] );  # children => child

    my $suffixLength = 1;

    foreach my $suffixGroup (@suffixGroups)
        {
        my $symbolSuffix = lc( substr($symbol, 0 - $suffixLength) );
        my $cutSymbol = substr($symbol, 0, 0 - $suffixLength);

        for (my $i = 0; $i + 1 < scalar @$suffixGroup; $i += 2)
            {
            my $suffix = $suffixGroup->[$i];
            my $replacement = $suffixGroup->[$i + 1];

            if ($symbolSuffix eq $suffix)
                {
                if (defined $replacement)
                    {
                    push @results, $cutSymbol . $replacement;
                    push @results, $cutSymbol . uc($replacement);
                    }
                else
                    {
                    push @results, $cutSymbol;
                    };
                };
            };

        $suffixLength++;
        };

    return @results;
    };


#
#   Function: AddInterpretation
#
#   Adds an interpretation to an existing reference.  Creates potential symbols as necessary.
#
#   Parameters:
#
#       referenceString  - The reference string to add the interpretation to.
#       class - The class of the symbol the reference can be interpreted as.  Undef if global.
#       symbol - The symbol the reference can be interpreted as.
#       score - The score of the interpretation
#
sub AddInterpretation #(referenceString, class, symbol, score)
    {
    my ($self, $referenceString, $class, $symbol, $score) = @_;

    my $interpretationString = $self->MakeSymbolString($class, $symbol);
    $references{$referenceString}->AddInterpretation($interpretationString, $score);

    # Create a potential symbol if it doesn't exist.

    if (!exists $symbols{$interpretationString})
        {  $symbols{$interpretationString} = NaturalDocs::SymbolTable::Symbol->New();  };

    $symbols{$interpretationString}->AddReference($referenceString, $score);
    };



#
#   Function: InterpretReference
#
#   Interprets the passed reference, matching it to the defined symbol with the highest score.  If the symbol is already
#   interpreted, it will reinterpret it.  If there are no matches, it will make it an undefined reference.
#
#   Parameters:
#
#       referenceString - The string of the reference to interpret.
#
sub InterpretReference #(referenceString)
    {
    my ($self, $referenceString) = @_;

    my $interpretation;
    my $currentInterpretation;
    my $score;
    my $currentScore = -1;

    my $referenceObject = $references{$referenceString};

    my %interpretationsAndScores = $referenceObject->InterpretationsAndScores();
    while ( ($interpretation, $score) = each %interpretationsAndScores )
        {
        if ($score > $currentScore && $symbols{$interpretation}->IsDefined())
            {
            $currentScore = $score;
            $currentInterpretation = $interpretation;
            };
        };

    if ($currentScore > -1)
        {  $referenceObject->SetCurrentInterpretation($currentInterpretation);  }
    else
        {  $referenceObject->SetCurrentInterpretation(undef);  };
    };


#
#   Function: MakeIndex
#
#   Generates a symbol index.
#
#   Parameters:
#
#       type  - The type to limit the index to, or undef if none.  Should be one of the <Topic Types>.
#
#   Returns:
#
#       A sorted arrayref of <NaturalDocs::SymbolTable::IndexElement> objects.
#
sub MakeIndex #(type)
    {
    my ($self, $type) = @_;

    my %indexHash;

    while (my ($symbolString, $object) = each %symbols)
        {
        my ($class, $symbol) = $self->DecodeSymbolString($symbolString);
        my @definitions = $object->Definitions();

        foreach my $definition (@definitions)
            {
            if (!defined $type || $type == $object->TypeDefinedIn($definition))
                {
                if (!defined $indexHash{$symbol})
                    {
                    $indexHash{$symbol} = NaturalDocs::SymbolTable::IndexElement->New($symbol, $class, $definition,
                                                                                                                              $object->TypeDefinedIn($definition),
                                                                                                                              $object->PrototypeDefinedIn($definition),
                                                                                                                              $object->SummaryDefinedIn($definition) );
                    }
                else
                    {
                    $indexHash{$symbol}->Merge($class, $definition, $object->TypeDefinedIn($definition),
                                                                 $object->PrototypeDefinedIn($definition), $object->SummaryDefinedIn($definition) );
                    };
                }; # If type matches
            }; # Each definition
        }; # Each symbol


    # Sort them and migrate them to an array.

    my $indexArray = [ keys %indexHash ];

    @$indexArray = sort { ::StringCompare($a, $b) } @$indexArray;

    for (my $i = 0; $i < scalar @$indexArray; $i++)
        {
        # Replace symbol names to IndexElement objects.
        $indexArray->[$i] = $indexHash{$indexArray->[$i]};

        # Sort its internal content as well.
        $indexArray->[$i]->Sort();
        };

    return $indexArray;
    };

1;
